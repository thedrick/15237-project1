<html>
<title> 15-237 Project 1 </title>
<head> <link href='http://fonts.googleapis.com/css?family=Croissant+One' rel='stylesheet' type='text/css'> </head>
<style>
#canvas {
  margin: 0 auto;
  text-align: center;
  display: block;
}
</style>
  <canvas id="canvas" width="1000", height="600", style="border:1px solid #000000"></canvas>
  <script>
  
  var currentPlayer;
  
  // CONSTANTS 
  var canvas;
  var ctx;
  var cursor;
  var characterSet;

  // tile constants
  var tileH;
  var tileW;
  var tileSize;

  // characters constants
  var charH;
  var charW;
  var charWoffset;
  var charHoffset;

  // Global states that represent the current actions allowed or unallowed
  var selectedCharacter;
  var actionMenuShowing;
  var characterIsMoving;
  var characterIsAttacking;
  var characterIsMagicking;
  var characterIsWaiting;
  var currentActionItem;
  var neighbors;
  var attack;
  var magic;

  // Load the tilesets
  var tileset;
  var characters;
  
  // gameboard
  var grid;
  // drawing code located in gameDrawing.js
  var drawTile;
  var drawActionMenuArrow;
  var containsmovement;
  var drawMovementSquares;
  var containsattack;
  var drawAttackSquares;
  var drawMagicSquares;
  var drawActionMenu;
  var drawStatusBox;
  var drawDirectionArrowUp;
  var drawDirectionArrowLeft;
  var drawDirectionArrowRight;
  var drawDirectionArrowDown;
  var drawWaitingArrows;
  var loadmap;
  var circle;
  var drawCharacterSide;
  
  // units code located in units.js
  var Archer;
  var Warrior;
  var Mage;
  var Ninja;
  var Cleric;
  
  // Event handlers - located in eventHandlers.js
  var madeActionSelection;
  var handleActionMenu;
  var alreadyOccupied;
  var characterAtLocation;
  var handleCharacterWaiting;
  var handleCharacterMoving;
  var handleCharacterAttacking;
  var handleCharacterMagicking;
  var handleCursorMovement;
  var keyboardHandler;
  
  // Defined below
  var App;
  var resetGameStates;
  var draw;
  
  // Unique ID generator
  var uniqueID = function() {
    var currentID = 0;
    return function() {
      return ++currentID;
    }
  }
  var uidGen = uniqueID();
  </script>
  
  <script src="gameDrawing.js" ></script>
  <script src="units.js"></script>
  <script src="eventHandlers.js"></script>
  <script>
  window.onload = function() {
    App();
  }
  
  App = function() {
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");
    characterSet = [];
    // tile constants
    tileH = 40;
    tileW = 40;
    tileSize = 16;

    // characters constants
    charH = 36;
    charW = 32;
    charWoffset = 3;
    charHoffset = 2;

    // Global states that represent the current actions allowed or unallowed
    currentPlayer = 1;
	selectedCharacter = null;
    actionMenuShowing = false;
    characterIsMoving = false;
    characterIsAttacking = false;
    characterIsWaiting = false;
    currentActionItem = 0;
    neighbors = new Array();
    attack = new Array();
	magic = new Array();
    
    tileset = new Image();
    tileset.src = "./resources/16tiles.png";
    tileset.onload = function() {
        loadmap(ctx);
    };
    characters = new Image();
    characters.src = "./resources/characters.png";
    
    // resets game states back to default values.
    resetGameState = function() {
      if (selectedCharacter !== null) {
        selectedCharacter.isSelected = false;
        selectedCharacter = null;
      }
      actionMenuShowing = false;
      characterIsMoving = false;
      characterIsAttacking = false;
      characterIsMagicking = false;
	  characterIsWaiting = false;
      currentActionItem = 0;
      neighbors = [];
      attack = [];
	  magic = [];
	  
	  var noMovesLeft = true;
	  for (var i = 0; i < characterSet.length; i++) {
		if (characterSet[i].myTurn && (!(characterSet[i].hasMoved && characterSet[i].hasAttacked))) {
			console.log(!(characterSet[i].hasAttacked && characterSet[i].hasMoved));
			noMovesLeft = false;
			break;
		}
	  }
	  if (noMovesLeft) {
		switchTurn();
	  }
    }
    
    // white outline around squares which represents the player's cursor. This allows the player
    // to make selections, pick tiles to move to, pick tiles to attack, etc.
    Cursor = function(ctx, x,y) {
      this.x = x;
      this.y = y;
      this.draw = function(ctx) {
        ctx.strokeStyle = "white"
        ctx.lineWidth = 2;
        ctx.strokeRect(tileW * this.x, tileH * this.y, tileW - 2, tileH - 2);
      }
      this.moveLeft = function() {
        if (this.x > 0) {
          this.x--;
        }
      }
      this.moveRight = function() {
        if (this.x < grid[0].length - 1) {
          this.x++;
        }
      }
      this.moveUp = function() {
        if (this.y > 0) {
          this.y--;
        }
      }
      this.moveDown = function() {
        if (this.y < grid.length - 1) {
          this.y++;
        }
      }
    }
    
    // initialize the cursor at the top left of the game board.
    cursor = new Cursor(ctx, 0,0); 
    
    canvas.addEventListener('keydown', keyboardHandler, true);
    canvas.setAttribute('tabindex', '0');
    canvas.focus();
    
    // populate the board with some starting units.
    characterSet.push(new Archer(ctx, 2,3, 1));
    characterSet.push(new Cleric(ctx, 2,2, 1));
    characterSet.push(new Ninja(ctx, 3,2, 1));
    characterSet.push(new Mage(ctx, 1,4, 1));
    characterSet.push(new Warrior(ctx, 3,4, 1));
    
	characterSet.push(new Archer(ctx, 6,9, 2));
    characterSet.push(new Cleric(ctx, 6,6, 2));
    characterSet.push(new Ninja(ctx, 9,6, 2));
    characterSet.push(new Mage(ctx, 3,12, 2));
    characterSet.push(new Warrior(ctx, 9,12, 2));
	
    // The draw function to continually update the canvas with data.
    draw = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      loadmap(ctx);
      characterSet.forEach(function(c) {
        if (c.isSelected) {
          if (actionMenuShowing) {
		    (c.isMagical) ? drawActionMagicMenu(ctx,c) : drawActionMenu(ctx, c);
          } else if (characterIsMoving) {
            drawMovementSquares(ctx, c.movementRange, c.x, c.y);
            for(var k=0; k<neighbors.length; k++){
              var xcord = neighbors[k][0];
              var ycord = neighbors[k][1];
              ctx.fillRect(tileW*xcord, tileH*ycord, 37,37);
            }
          } else if (characterIsAttacking) {
            drawAttackSquares(ctx, c.attackRange, c.x, c.y);
			 for(var k=0; k<attack.length; k++){
              var xcord = attack[k][0];
              var ycord = attack[k][1];
              ctx.fillRect(tileW*xcord, tileH*ycord, 37,37);
            }
          }
		  else if (characterIsMagicking) {
            drawMagicSquares(ctx, c.magicRange, c.x, c.y);
			 for(var k=0; k<magic.length; k++){
              var xcord = magic[k][0];
              var ycord = magic[k][1];
              ctx.fillRect(tileW*xcord, tileH*ycord, 37,37);
            }
          }
          drawStatusBox(ctx, c);
        }
        c.draw(ctx);
      });
      characterSet.forEach(function(c) {
        if (characterIsMoving) {
          drawTile(ctx, c.x, c.y);
        }
        c.draw(ctx);
      });
      if (characterIsWaiting) {
        drawWaitingArrows(ctx, selectedCharacter);
      } else {
        cursor.draw(ctx);
      }
    }
    
    // draw at 30 FPS
    setInterval(draw, 1000 / 30);
  }
  </script>  
</html>